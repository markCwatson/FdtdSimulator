%% MI__V0.11.0

% By Mark Watson
% Aug 2021

%%
% main

clc 
clear
clear all
close all
digits(10)
time_all = tic;

% setup
[number_of_Rx, angle_degrees_start, angle_degrees_diff, c0,...
Eps0, u0, freq, sigma_H2O, sigma_air, Er_H2O, Er_air, lambda_res,...
convergence_iteration, max_convergence_iterations, dim_res, t0, tau,...
do_convergence_iterations, threshold, input_mode, I_max, do_PML,...
Vin_Amp, N_Tx, radius_Tx, b_Tx, f0_desired, R_Tx, C_Tx, sigma_wire, num_periods,...
height_Tx, height_H2O, height_Rx, height_max, center_Rx, center_Tx, width, increase,...
do_annimation, fmax, fmin, plot_fields, plot_fft, input_type,...
N_Rx, radius_Rx, b_Rx, C_Rx, R_Rx, converg_test_type, scale_high, scale_low,...
fmax_pulse, FFT_resolution, iterations_until_getframe, do_initial_validity_test,...
do_initial_validity_test_annimation, do_initial_validity_test_video, last_output_max,...
use_two_Tx_coils, height_Rx_opt]...
    = MI_setup();

% define geometry
[RX2_rho, RX1_rho, RX2_z, RX1_z, SRC2_rho, SRC1_rho, SRC2_z, SRC1_z,...
lambda_res, dt, T_STEPS, Nrho, Nz, i_SRC1, j_SRC1, i_SRC2, skin_depth,...
j_SRC2, depthInH2O_Tx, i_Rx, j_Rx, i_Tx, j_Tx, RHO, Z, PML_thickness, lambda_H2O, lambda_air,...
drho, dz, j_H2O_height, heightFromH2O_Rx, dmin_lambda, dmin_dim,...
i_SRC3, j_SRC3, i_SRC4, j_SRC4, i_Rx_opt, j_Rx_opt, angle_degrees, slope, dx]...
    = MI_geometry(c0, freq, u0, Eps0, sigma_H2O, Er_H2O, lambda_res, dim_res,...
        radius_Tx, num_periods, height_Tx, height_H2O, height_Rx,...
        number_of_Rx, angle_degrees_start, angle_degrees_diff,...
        height_max, center_Rx, center_Tx, width, radius_Rx, input_type,...
        FFT_resolution, use_two_Tx_coils, height_Rx_opt);

% generate material grid
[Eps, mySigma]...
        = MI_materialGrid(Nrho, Nz, Eps0, j_H2O_height, sigma_H2O,...
            sigma_air, Er_H2O, Er_air, drho, dz, RHO, Z);

% construct PML
[A, B, C, D, E, F, G, H, I, J, K, L]...
        = MI_PML2(Nrho, Nz, dt, Eps, u0, mySigma, PML_thickness, do_PML);

% print important test parameters
MI_printParams(freq, dt, T_STEPS, drho, sigma_H2O, lambda_H2O, skin_depth, lambda_air,...
    I_max, N_Tx, radius_Tx, depthInH2O_Tx, N_Rx, radius_Rx, heightFromH2O_Rx);

% generate output from Tx coil
[H_Tx, Vin, I_Tx]...
        = MI_generateTxCoilOutput(input_type, input_mode,...
            I_max, Vin_Amp, T_STEPS, dt, freq, N_Tx, u0, radius_Tx, b_Tx,...
            f0_desired, R_Tx, sigma_wire, t0, tau, fmax_pulse, drho);

% initialization
[sample_Rx_Hz, sample_Rx_Hrho, sample_Rx_Ephi, sample_Tx_Hz,...
sample_Tx_Hrho, sample_Tx_Ephi, sample_Rx_Hz_flux, sample_Rx_Hrho_flux,...
Ephi_tot, Hz_tot, Hrho_tot, IEphi, Curl_H_phi, curl_E_rho, ICErho, curl_E_z, ICEz,...
IHrho, IHz, ICHphi, diff, sample_Rx_opt_flux, vidObj]...
    = MI_initialize(T_STEPS, Nrho, Nz, do_annimation, radius_Rx, i_Rx, i_Rx_opt,...
        number_of_Rx, drho, dx);

time_FDTD_allSteps = tic;

for n = 1:T_STEPS   

    % to see that program is running
    clc
    sprintf('time step %d of %d', n, T_STEPS)

    time_FDTD_perStep = tic;

    % inject source
    [Hz_tot, Hrho_tot]...
        = MI_source(i_SRC1, j_SRC1, H_Tx, Hz_tot, Hrho_tot, n,...
            i_SRC3, j_SRC3, i_SRC4, j_SRC4, use_two_Tx_coils);

    % run FDTD algorithm
    [Ephi_tot, Hz_tot, Hrho_tot, IEphi, ICErho, ICEz, IHrho, IHz, ICHphi]...
        = MI_FDTDalgorithmCyl3(Nrho, Nz, drho, dz, Ephi_tot, Hz_tot, Hrho_tot,...
            A, B, C, D, E, F, G, H, I, J, K, L,...
            IEphi, Curl_H_phi, curl_E_rho, ICErho, IHrho, curl_E_z, ICEz, IHz, ICHphi);

    % sample signal
    [sample_Rx_Hz, sample_Rx_Hrho, sample_Rx_Ephi,...
    sample_Tx_Hz, sample_Tx_Hrho, sample_Tx_Ephi,...
    sample_Rx_Hz_flux, sample_Rx_Hrho_flux, sample_Rx_opt_flux]...
        = MI_sample(Hz_tot, Hrho_tot, Ephi_tot, n,...
            i_Rx, j_Rx, i_Tx, j_Tx, radius_Rx,...
            sample_Rx_Hz, sample_Rx_Hrho, sample_Rx_Ephi,...
            sample_Tx_Hz, sample_Tx_Hrho, sample_Tx_Ephi,...
            sample_Rx_Hz_flux, sample_Rx_Hrho_flux, drho, ...
            sample_Rx_opt_flux, number_of_Rx, i_Rx_opt, j_Rx_opt,...
            slope, dx);

    % create animation
    if (do_annimation == true)

        if ((mod(n, iterations_until_getframe) == 0) || (n == 1) || (n == T_STEPS))

            MI_animation(n, T_STEPS, RHO, Z, Hz_tot, Hrho_tot, dt,...
                drho, Nrho, dz, Nz, height_H2O, sigma_H2O,...
                vidObj, freq, angle_degrees_start, angle_degrees_diff,...
                scale_high, scale_low, PML_thickness,...
                SRC2_rho, SRC1_rho, SRC2_z, SRC1_z, height_Rx,...
                RX2_rho, RX1_rho, RX1_z, RX2_z, do_annimation,...
                sigma_air, height_Rx_opt, number_of_Rx);
           %pause 
        end

    else 

        if ((mod(n, ceil(T_STEPS/10)) == 0) || (n == 1))

            MI_animation(n, T_STEPS, RHO, Z, Hz_tot, Hrho_tot, dt,...
                drho, Nrho, dz, Nz, height_H2O, sigma_H2O,...
                vidObj, freq, angle_degrees_start, angle_degrees_diff,...
                scale_high, scale_low, PML_thickness,...
                SRC2_rho, SRC1_rho, SRC2_z, SRC1_z, height_Rx,...
                RX2_rho, RX1_rho, RX1_z, RX2_z, do_annimation,...
                sigma_air, height_Rx_opt, number_of_Rx);
           %pause 
        end

    end

    time_FDTD_perStep = toc(time_FDTD_perStep);

end

time_FDTD_allSteps = toc(time_FDTD_allSteps);

% generate output from Rx coil    
[Vo, Vo_max, Vo_opt_max, I_Rx_max]...
    = MI_generateRxCoilOutput2(T_STEPS, dt, N_Rx,...
        u0, radius_Rx, b_Rx, f0_desired, sample_Rx_Hz_flux, ...
        sample_Rx_Hrho_flux, R_Rx, I_Tx, Vin, input_mode, ...
        input_type, sample_Rx_opt_flux, angle_degrees, number_of_Rx);

if (do_annimation == true)

    % close video file
    close(vidObj);

end

% plot fields
if (plot_fields == true)

    MI_plotHcomponents(sample_Tx_Hz, sample_Tx_Hrho, sample_Rx_Hz, sample_Rx_Hrho, dt, T_STEPS);
    MI_plotEcomponent(sample_Tx_Ephi, sample_Rx_Ephi, dt, T_STEPS);

end

% valifation agains Wait/Gibson (only for case where air-water interface)
if ((sigma_air == 0) && (number_of_Rx == 1))

    MI_Validation(I_max, N_Tx, N_Rx, Vo_max, Vo_opt_max, radius_Tx, u0, sigma_H2O,...
        depthInH2O_Tx, heightFromH2O_Rx, freq, fmax, fmin);

end

time_all = toc(time_all);

for i = 1:number_of_Rx

    sprintf('Vo_max = %.2f dBV, Io_max = %.2f dBA, Vo_opt_max = %.2f dBV, 20*log(Vo_max/Vo_opt_max) = %.1f dB, angle = %.2f degrees',...
        20*log10(Vo_max(i)), 20*log10(I_Rx_max(i)), 20*log10(Vo_opt_max), 20*log10(Vo_max(i)/Vo_opt_max), angle_degrees(i))

end

sprintf('time_all = %.2f mins, time_FDTD_perStep = %.3f ms',...
    time_all/60, 1000*time_FDTD_perStep)

%FIN